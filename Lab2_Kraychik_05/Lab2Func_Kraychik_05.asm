; -------------------------------------------------------------------------------------        
;        Лабораторная работа №1 по курсу Программирование на языке ассемблера                                
;        Вариант №5.                                                                                                                                                
;        Выполнил Георгий Крайчик. Группа 344                                                                                                
;
;        Исходный модуль Lab1Func_Kraychik_05.asm                                                           
;        Содержит функции на языке ассемблера, разработанную в соответствии с заданием                     
;		 В качестве неприводимого многочлена выбран f = x^64 + x^4 + x^3 + x + 1
;		 Т.о. GF2_64 = Z/2Z[x] / f
;		 Вычитание совпадает со сложением
;		 Все многочлены над полем GF2_64 хранятся в памяти от старших коэффицентов к младшим,
;		 то есть коэффицент при старшей степени многочлена хранится в нулевой ячейке массива
; -------------------------------------------------------------------------------------

.CODE

; GF2_64 GF_MulX(GF2_64 a)
; Умножение элемента поля а на х
; Если a < 0, то после умножения на х его необходимо факторизовать по x^64 + x^4 + x^3 + x + 1
; При этом из-за арифметики переполнения, старший бит числа исчезнет, то есть факторизовать нужно будет по x^4 + x^3 + x + 1
; Если a >= 0, результатом будет являться сдвиг влево на 1 разряд
GF_MulX PROC							; rcx - a (элемент поля)
	cmp rcx, 0							; сравнение элемента а и 0
	mov rdx, 27							; 27 = x^4 + x^3 + x + 1
	mov r8, 0							; подготовка к команде cmovg
	cmovg rdx, r8						; rdx = (rcx < 0) ? 27 : 0
	sal rcx, 1							; умножение на x
	xor rcx, rdx						; факторизация
	mov rax, rcx						; возвращаемое значение
	ret
GF_MulX ENDP

; GF2_64 GF_PowX(unsigned int Power);
; Возведение x в степень Power
GF_PowX PROC							; ecx - Power (unsigned int)
	; сохранение значений регистров на стек
	push rbx
	push rbp
	mov rbp, 1							; присвоение начального значения
										; далее следует цикл с Power итераций
	m2:
		cmp rcx, 0						; сравнение rcx и 0
		je m1							; если rcx == 0, переход к метке m1
		mov rbx, rcx					; копирование rcx на rbx
		mov rcx, rbp					; запись на rcx rbp, чтобы передать в функцию rbp
										; в качестве параметра функции
		call GF_MulX
		mov rbp, rax					; запись результата работы функции на rbp
		mov rcx, rbx					; восстановление счетчика на rcx
		dec rcx							; уменьшение счетчика
		jmp m2							; переход к метке m2
	m1:
	mov rax, rbp						; на rax находится возвращаемое значение
	; восстановление значений
	pop rbp
	pop rbx
	ret
GF_PowX ENDP

; GF2_64 GF_Multiply(GF2_64 a, GF2_64 b);
; Умножение двух элементов поля
; Реализация: находится сумма произведений элемента a на каждый бит элемента b
GF_Multiply PROC						; rcx - a (первый элемент)
										; rdx - b (второй элемент)
	; сохранение значений в стеке для последующего восстановления
	push r15
	push r14
	push r13
	push r12
	push rsi
	; умножение нулевого бита элемента b на a 
	mov r15, rcx						; копирование rcx на r15
	mov r14, rdx						; копирование rdx на r14
	xor rax, rax						; обнуление rax
	bt rdx, 0							; копирование нулевого бита rdx в флаг CF
	setc al								; если CF == 1, записать в al единицу
	cmp rax, 0							; сравнение rax и 0
	mov rax, r15						; на rax записываем r15 (значение первого элемента)
	mov rcx, 0							; обнуление rcx
	cmove rax, rcx						; if (rax == 0) { rax = 0; }
										; rax содержит произведение нулевого бита элемента b на элемент a
	mov r13, rax						; r13 содержит текущее произведение
	mov r12, r15						; r12 будет сожержать a*(x^i), где i = 0..63
										; в данный момент i == 0
	xor rsi, rsi						; rsi - количество итераций цикла, обнуление
	; цикл по всем битам b
	m1:
		cmp rsi, 63						; сравнение rsi и 63
		je m2							; если rsi == 63, переход к метке m2
		inc rsi							; rsi++
		mov rcx, r12					; подготовка к вызову GF_MulX
		call GF_MulX
		mov r12, rax					; обновление значения r12 = a*(x^rsi)
		; извлечение бита номер rsi из регистра r14
		xor rax, rax					; обнуление rax
		bt r14, rsi						; выделение бита номер rsi из элемента r14 и его запись в флаг CF
		setc al							; копирование флага CF на регистр al
		; умножение элемента r12 на выделенный бит (хранится в rax)
		cmp rax, 1						; сравнение выделенного бита (rax) с 1
		mov rax, r12					; запишем на rax результат умножения r12 на 1 (т.е. запишем r12)
		mov rcx, 0						; подготовка к следующей команде
		cmovne rax, rcx					; if (rax != 1) { rax = 0; }
		xor r13, rax					; добавление к регистру, содержащему результат
		jmp m1
	m2:
	mov rax, r13						; возвращаемое значение
	; восстановление значений
	pop rsi
	pop r12
	pop r13
	pop r14
	pop r15
	ret
GF_Multiply ENDP

; GF2_64 GF_Reciprocal(GF2_64 a)
; Нахождение обратного элемента в поле
; a^(-1) = a^(2^64-2) = a^(2^0) * a^(2^1) * a^(2^2) * ... * a^(2^63)
GF_Reciprocal PROC						; rcx - a (элемент поля)
	; сохранения значений регистров для последующего восстановления
	push rbx
	push rbp
	push r12
	push rsi
	; подготовка к вызову GF_Multiply
	mov rbx, rcx						; копирование a (первый аргумент уже на rcx)
	mov rdx, rbx						; копирование a (второй аргумент)
	call GF_Multiply					; вызов GF_Multiply
	mov rbp, rax						; rbp - переменная, которая будет возводится в квадрат
	mov r12, rbp						; r12 - в нем хранится результат
	mov rcx, 62							; счетчик цикла
	m1:
		mov rsi, rcx					; сохранение счетчика цикла
		; подготовка к вызову GF_Multiply (возведение в квадрат)
		mov rcx, rbp					; первый аргумент
		mov rdx, rbp					; второй аргумент
		call GF_Multiply
		mov rbp, rax					; сохранение результата возведения в квадрат
		; подготовка к вызову GF_Multiply (текущее произведение)
		mov rcx, rbp					; первый аргумент
		mov rdx, r12					; второй аргумент
		call GF_Multiply
		mov r12, rax					; сохранение результата
		mov rcx, rsi					; восстановление счетчика цикла
		loop m1							; уменьшение rcx, условный переход к m1
	mov rax, r12						; возвращаемое значение
	; восстановление значений регистров из стека
	pop rsi
	pop r12
	pop rbp
	pop rbx
	ret
GF_Reciprocal ENDP

; int PolyMulX(GF2_64 *a, int deg)
; Умножение многочлена над полем GF2_64 на x
; Степень многочлена-результата больше исходной на единицу, если многочлен отличен от нуля
PolyMulX PROC							; rcx - указатель на многочлен a
										; edx - степень многочлена deg, тип данных int
	mov rax, -1							; если deg == -1, вернем значение -1
	cmp edx, -1							; тип int является 32-битным
	je m1								; если deg == 1, конец функции
	inc rdx								; степень результата на 1 больше степени многочлена
	mov r8, rdx							; подготовка к умножению
	mov rax, 8							; каждая переменная GF2_64 занимает 8 байт
	imul rdx							; в rax находится величина сдвига в массиве
	mov r9, 0							; при умножении на x, коэффицент
										; при младшей степени становится нулем
	mov [rcx+rax], r9					; a[deg+1] = 0
	mov rax, r8							; возвращается степень нового многочлена
	m1:
	ret
PolyMulX ENDP

; int PolyMulConst(GF2_64 *a, int deg, GF2_64 c)
; Умножение многочлена на элемент поля GF2_64
; Степень многочлена-результата не изменяется
PolyMulConst PROC						; rcx - указатель на массив a
										; rdx - степень многочлена deg, имеет тип int
										; r8 - элемент поля GF2_64
	; если константа равна 0, вернем степень -1
	mov rax, -1			
	cmp r8, 0							; сравнение константы с нулем
	je m3								; если константа равна 0, прекращаем работу функции
	cmp edx, -1							; сравнение степени с -1 (int 32-битный)
	je m3								; если они равны, завершить процедуру, вернув -1
	; сохранение значений в стеке
	push r15
	push r14
	push r13
	push rsi
	; сохранение значений rcx, rdx, r8
	mov r15, rcx
	mov r14, rdx
	mov r13, r8
	xor rsi, rsi						; обнуление счетчика для цикла
	m2:
		cmp rsi, r14					; сравнение счетчика и deg
		jg m1							; если rsi > deg прерываем цикл
		mov rcx, [r15+8*rsi]			; вычисление адреса текущего коэффицента многочлена
										; и запись его на регистр rcx
		mov rdx, r13					; запись константы на rdx
		call GF_Multiply				; нахождение произведения rcx и rdx
		mov [r15+8*rsi], rax			; запись произведения в массив
		inc rsi							; увеличение счетчика на единицу
		jmp m2
	m1:
	; восстановление значений из стека
	mov rax, r14						; возвращаемым значением является степень многочлена
	pop rsi
	pop r13
	pop r14
	pop r15
	m3:
	ret
PolyMulConst ENDP

; int PolyZero(GF2_64 *a, int deg)
; Обнуление многочлена (обнуление всех его коэффицентов)
; Возвращаемое значение всегда равно -1
PolyZero PROC							; rcx - указатель на массив a
										; edx - степень многочлена deg, является типом int
	cmp edx, -1							; сравнение deg и -1
	je m2;								; завершение процедуры, так как многочлен уже равен 0
	pxor xmm0, xmm0						; обнуление xmm0
	mov rax, 0							; счетчик цикла
	cycle:
		movdqu xmmword ptr[rcx+8*rax], xmm0		; обнуление сразу же двух коэффицентов многочлена
		add rax, 2								; увеличение счетчика на 2
		cmp rax, rdx							; сравнение rax и rdx
		jl cycle								; if (счетчик rax < rdx) { continue; }
	; имеется 2 варианта: либо (rax == rdx), либо (rax == rdx + 1)
	xor r8, r8							; обнуление r8 (будет использоваться для обнуления памяти)
	cmp rax, rdx						; сравнение счетчика и степени
	jg m2;								; if (rax == rdx) { goto m2; }
	mov qword ptr[rcx+8*rax], r8		; обнуление очередного коэффицента исходного многочлена
	inc rax;							; увеличение rax на 1
	cmp rax, rdx						; сравнение счетчика и степени
	jg m2;								; если (rax > rdx) { goto m2; }
	mov qword ptr[rcx+8*rax], r8		; обнуление  коэффицента исходного многочлена
	m2:
	mov eax, -1							; возвращаемая степень многочлена равна -1
	ret
PolyZero ENDP

; int PolyCpy(GF2_64 *dest, GF2_64 *src, unsigned char deg)
; Копирование многочлена из src в dest
PolyCpy PROC							; rcx - указатель на приемник (dest)
										; rdx - указатель на источник (src)
										; r8 - степень многочлена deg, имеет тип unsigned char
	
	; сохранение регистров в памяти
	push rsi
	push rdi

	mov r9, rcx							; копирование rcx на r9
	mov rax, r8							; возвращаемое значение
	mov rsi, rdx						; адрес источника
	mov rdi, r9							; адрес приемника
	mov rcx, r8							; счетчик
	inc rcx								; степень на 1 меньше кол-ва коэффицентов
	cld									; значение будет увеличиваться
	rep movsq							; копирование массива, на rcx счетчик
	; восстановление значений регистров
	pop rdi
	pop rsi
	ret
PolyCpy ENDP

; int PolySum(GF2_64 *sum, GF2_64 *a, int deg_a, GF2_64 *b, int deg_b)
; Сложение многочленов над полем GF2_64
; Возвращается max(deg_a, deg_b)
PolySum PROC							; rcx - адрес результата (sum)
										; rdx - адрес первого многочлена (a)
										; r8 - степень первого многолчена (deg_a)
										; r9 - адрес второго многочлена (b)
										; [rsp+40] - степень второго многочлена (deg_b)
	
	mov eax, [rsp+40]					; теперь на eax лежит deg_b
	; сохранение значений регистров
	push r12
	push r13
	push r14
	cdqe								; знаковое расширение eax до rax
	; расширение r8d до r8
	xchg rax, r8
	cdqe
	xchg rax, r8
	; теперь все используемые регистры 64-битные
	mov r10, r8							; инициализация первого индекса i
	mov r12, rax						; инициализация второго индекса j
	; запись на r13 максимума из deg_a, deg_b
	mov r13, r8							; r13 - индекс в массиве sum, обозначим k
	cmp r8, rax							; сравнение deg_a и deg_b
	cmovl r13, rax						; если r8 < rax => r13 = rax
	mov r14, r13						; копирование r13 в r14
	; далее следуют циклы
	m1:
		cmp r10, 0						; сравнение r10 и 0
		jl m2							; если r10 < 0, переход к метке m2
		cmp r12, 0						; сравнение r12 и 0
		jl m2							; если r12 < 0, переход к метке m2
		mov r11, [rdx+8*r10]			; r11 = a[i]
		xor r11, [r9+8*r12]				; r11 += b[j]
		mov [rcx+8*r13], r11			; sum[k] = a[i] + b[j]
		dec r10							; i--
		dec r12							; j--
		dec r13							; k--
		jmp m1
	m2:
		cmp r10, 0						; сравнение i и 0
		jl m3							; если i < 0, переход к m3
		mov r11, [rdx+8*r10]			; r11 = a[i]
		mov [rcx+8*r13], r11			; sum[k] = a[i]
		dec r10							; i--
		dec r13							; k--
		jmp m2
	m3:
		cmp r12, 0						; сравнение j и 0
		jl m4							; если j < 0, переход к m4
		mov r11, [r9+8*r12]				; r11 = b[j]
		mov [rcx+8*r13], r11			; sum[k] = b[j]
		dec r12							; j--
		dec r13							; k--
		jmp m3
	m4:
	mov rax, r14						; возвращаемым значением является max(deg_a, deg_b)
	; восстановление значений регистров
	pop r14
	pop r13
	pop r12
	ret
PolySum ENDP

END