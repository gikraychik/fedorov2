; -------------------------------------------------------------------------------------        
;        Лабораторная работа №2 по курсу Программирование на языке ассемблера                                
;        Вариант №5.                                                                                                                                                
;        Выполнил Георгий Крайчик. Группа 344                                                                                                
;
;        Исходный модуль Lab2Func_Kraychik_05.asm                                                           
;        Содержит функции на языке ассемблера, разработанные в соответствии с заданием                     
;		 В качестве неприводимого многочлена выбран f = x^64 + x^4 + x^3 + x + 1
;		 Т.о. GF2_64 = Z/2Z[x] / f
;		 Вычитание совпадает со сложением
;		 Все многочлены над полем GF2_64 хранятся в памяти от старших коэффицентов к младшим,
;		 то есть коэффицент при старшей степени многочлена хранится в нулевой ячейке массива
;
;		 SSE используется в GF_Multiply и PolyZero.
; -------------------------------------------------------------------------------------

.DATA
	ALIGN 16								; выравнивание данных на границу 16 байт
	; исользуется в GF_Multiply
	Modulo	oword 1Bh						; x^64 + x^4 + x^3 + x + 1 (младшая часть)

.CODE

; GF2_64 GF_MulX(GF2_64 a)
; Умножение элемента поля а на х
; Если a < 0, то после умножения на х его необходимо факторизовать по x^64 + x^4 + x^3 + x + 1
; При этом из-за арифметики переполнения, старший бит числа исчезнет, то есть факторизовать нужно будет по x^4 + x^3 + x + 1
; Если a >= 0, результатом будет являться сдвиг влево на 1 разряд
GF_MulX PROC							; rcx - a (элемент поля)
	cmp rcx, 0							; сравнение элемента а и 0
	mov rdx, 27							; 27 = x^4 + x^3 + x + 1
	mov r8, 0							; подготовка к команде cmovg
	cmovg rdx, r8						; rdx = (rcx < 0) ? 27 : 0
	sal rcx, 1							; умножение на x
	xor rcx, rdx						; факторизация
	mov rax, rcx						; возвращаемое значение
	ret
GF_MulX ENDP

; GF2_64 GF_PowX(unsigned int Power);
; Возведение x в степень Power
GF_PowX PROC							; ecx - Power (unsigned int)
	; сохранение значений регистров на стек
	push rbx
	push rbp
	mov rbp, 1							; присвоение начального значения
										; далее следует цикл с Power итераций
	mov rbx, rcx						; rbx - счетчик цикла
	cmp rbx, 0							; сравнение Power и 0
	je m1								; if (Power == 0) { переход к метке m1; }
	m2:
		mov rcx, rbp					; запись на rcx rbp, чтобы передать в функцию rbp
										; в качестве параметра функции
		call GF_MulX
		mov rbp, rax					; запись результата работы функции на rbp
		dec rbx							; уменьшение счетчика
		cmp rbx, 0						; сравнение rcx и 0
		jne m2							; if (rcx != 0) { переход к m2 (продолжение цикла); }
	m1:
	mov rax, rbp						; на rax находится возвращаемое значение
	; восстановление значений из стека
	pop rbp
	pop rbx
	ret
GF_PowX ENDP

; GF2_64 GF_Multiply(GF2_64 a, GF2_64 b);
; Умножение двух элементов поля
; Реализация: находится сумма произведений элемента a на каждый бит элемента b
GF_Multiply PROC						; rcx - a (первый элемент)
										; rdx - b (второй элемент)
	movd xmm0, rcx;						; запись rcx на xmm0
	movd xmm1, rdx;						; запись rdx на xmm1
	pclmulqdq xmm0, xmm1, 00h			; умножение многочленов, запись результата в xmm2

	; далее необходимо профакторизовать полученный многочлен xmm0 по x^64 + x^4 + x^3 + x + 1
	; пользуемся алгоритмом Баррета

	movdqa xmm1, Modulo;				; xmm1 = 1B
	pclmulqdq xmm1, xmm0, 10h			; умножение младшей половины xmm1 на старшую половину xmm0, результат в xmm1
	pxor xmm1, xmm0						; сложение xmm1 и xmm0 в поле
	pclmulqdq xmm1, Modulo, 01h			; умножение старшей половины xmm1 на младшую половину Modulo, результат в xmm1
	pxor xmm0, xmm1						; сложение xmm0 и xmm1 в поле
	pextrq rax, xmm0, 0h				; пересылка младших 64-х бит xmm0 на rax 
	ret									; возвращается значение rax
GF_Multiply ENDP

; GF2_64 GF_Reciprocal(GF2_64 a)
; Нахождение обратного элемента в поле
; a^(-1) = a^(2^64-2) = a^(2^0) * a^(2^1) * a^(2^2) * ... * a^(2^63)
GF_Reciprocal PROC						; rcx - a (элемент поля)
	; сохранения значений регистров для последующего восстановления
	push rbp
	push r12
	push rsi
	; подготовка к вызову GF_Multiply
	mov rdx, rcx						; копирование a (второй аргумент)
	call GF_Multiply					; вызов GF_Multiply
	mov rbp, rax						; rbp - переменная, которая будет возводится в квадрат
	mov r12, rbp						; r12 - в нем хранится результат
	mov rsi, 62							; счетчик цикла
	cycle:
		; подготовка к вызову GF_Multiply (возведение в квадрат)
		mov rcx, rbp					; первый аргумент
		mov rdx, rbp					; второй аргумент
		call GF_Multiply
		mov rbp, rax					; сохранение результата возведения в квадрат
		; подготовка к вызову GF_Multiply (текущее произведение)
		mov rcx, rbp					; первый аргумент
		mov rdx, r12					; второй аргумент
		call GF_Multiply
		mov r12, rax					; сохранение результата
		dec rsi							; уменьшение счетчика rsi
		cmp rsi, 0						; сравнение rsi и 0
		jg cycle						; if (rsi > 0) { переход к cycle }
	mov rax, r12						; возвращаемое значение
	; восстановление значений регистров из стека
	pop rsi
	pop r12
	pop rbp
	ret
GF_Reciprocal ENDP

; int PolyMulX(GF2_64 *a, int deg)
; Умножение многочлена над полем GF2_64 на x
; Степень многочлена-результата больше исходной на единицу, если многочлен отличен от нуля
PolyMulX PROC							; rcx - указатель на многочлен a
										; edx - степень многочлена deg, тип данных int
	mov rax, -1							; если deg == -1, вернем значение -1
	cmp edx, -1							; тип int является 32-битным
	je m1								; если deg == 1, конец функции
	inc rdx								; степень результата на 1 больше степени многочлена
	mov r9, 0							; при умножении на x, коэффицент
										; при младшей степени становится нулем
	mov [rcx+8*rdx], r9					; a[deg+1] = 0
	mov rax, rdx						; возвращается степень нового многочлена
	m1:
	ret
PolyMulX ENDP

; int PolyMulConst(GF2_64 *a, int deg, GF2_64 c)
; Умножение многочлена на элемент поля GF2_64
; Степень многочлена-результата не изменяется
PolyMulConst PROC						; rcx - указатель на массив a
										; rdx - степень многочлена deg, имеет тип int
										; r8 - элемент поля GF2_64
	; если константа равна 0, вернем степень -1
	mov rax, -1							; возвращаемое значение при условии, что deg == -1		
	cmp r8, 0							; сравнение константы с нулем
	je m3								; если константа равна 0, прекращаем работу функции
	cmp edx, -1							; сравнение степени с -1 (int 32-битный)
	je m3								; если они равны, завершить процедуру, вернув -1
	; сохранение значений в стеке
	push r15
	push r14
	push r13
	push rsi
	; сохранение значений rcx, rdx, r8
	mov r15, rcx						; r15 <- указатель на массив a
	mov r14, rdx						; r14 <- deg
	mov r13, r8							; r13 <- c
	xor rsi, rsi						; обнуление счетчика для цикла
	; уже извстно, что deg > -1
	; таким образом выполнится хотя бы 1 итерация цикла
	m2:
		mov rcx, [r15+8*rsi]			; запись адреса текущего коэффицента многочлена на rcx
		mov rdx, r13					; запись константы на rdx
		call GF_Multiply				; нахождение произведения rcx и rdx
		mov [r15+8*rsi], rax			; запись произведения в массив
		inc rsi							; увеличение счетчика на единицу
		cmp rsi, r14					; сравнение счетчика и deg
		jle m2							; if (rsi < deg) { continue; }
	m1:
	mov rax, r14						; возвращаемым значением является степень многочлена
	; восстановление значений из стека
	pop rsi
	pop r13
	pop r14
	pop r15
	m3:
	ret
PolyMulConst ENDP

; int PolyZero(GF2_64 *a, int deg)
; Обнуление многочлена (обнуление всех его коэффицентов)
; Возвращаемое значение всегда равно -1
PolyZero PROC							; rcx - указатель на массив a
										; edx - степень многочлена deg, является типом int
	cmp edx, -1							; сравнение deg и -1
	je m2;								; завершение процедуры, так как многочлен уже равен 0
	pxor xmm0, xmm0						; обнуление xmm0
	mov r8, 1							; r8 = 1
	mov r9, rdx							; r9 = rdx
	sub r9, r8							; r9 = rdx - 1
	; в зависимости от четности будем изменять значение rdx на r9 = rdx - 1
	; проверка, является ли deg нечетным числом
	mov rax, rdx						; rax = deg
	shr rax, 1							; сдвиг rax на 1 бит вправо
	shl rax, 1							; сдвиг rax на 1 бит влево
	cmp rax, rdx						; сравнение rax и deg
										; если они равны, то deg четен, иначе нечетен
	cmove rdx, r9						; if (deg четна) { deg--; }
	mov r8, 1							; r8 = 1
	mov r10, 0							; r10 = 0 (r10 означает величину, на которую умешьшают deg)
										; r10 может быть равно либо 0, либо 1
	cmove r10, r8						; if (deg нечетна) { r10 = 1; } else { r10 = 0; }
	mov r8, 0							; счетчик цикла
	cycle:
		movdqa xmmword ptr[rcx+8*r8], xmm0		; обнуление сразу же двух коэффицентов многочлена
		add r8, 2								; увеличение счетчика на 2
		cmp r8, rdx								; сравнение r8 и deg
		jl cycle								; if (счетчик r8 < deg) { continue; }	
	add rdx, r10						; восстановление исходного значения deg
	cmp rax, rdx						; сравнение rax и deg
	jne m2								; if (rax != deg) { переход к метке m2 }
	xor rax, rax						; rax = 0
	mov qword ptr[rcx+8*rdx], rax		; запись 0 в последний элемент массива
	m2:
	mov eax, -1							; возвращаемая степень многочлена равна -1 (int)
	ret
PolyZero ENDP

; int PolyCpy(GF2_64 *dest, GF2_64 *src, unsigned char deg)
; Копирование многочлена из src в dest
PolyCpy PROC							; rcx - указатель на приемник (dest)
										; rdx - указатель на источник (src)
										; r8 - степень многочлена deg, имеет тип unsigned char
	
	; сохранение регистров в памяти
	push rsi
	push rdi

	mov r9, rcx							; копирование rcx на r9
	mov rax, r8							; возвращаемое значение
	mov rsi, rdx						; адрес источника
	mov rdi, r9							; адрес приемника
	mov rcx, r8							; счетчик
	inc rcx								; степень на 1 меньше кол-ва коэффицентов
	cld									; значение будет увеличиваться
	rep movsq							; копирование массива, на rcx счетчик
	; восстановление значений регистров
	pop rdi
	pop rsi
	ret
PolyCpy ENDP

; int PolySum(GF2_64 *sum, GF2_64 *a, int deg_a, GF2_64 *b, int deg_b)
; Сложение многочленов над полем GF2_64
; Возвращается max(deg_a, deg_b)
PolySum PROC							; rcx - адрес результата (sum)
										; rdx - адрес первого многочлена (a)
										; r8 - степень первого многолчена (deg_a)
										; r9 - адрес второго многочлена (b)
										; [rsp+40] - степень второго многочлена (deg_b)
	
	mov eax, [rsp+40]					; теперь на eax лежит deg_b
	; сохранение значений регистров
	push r12
	push r13
	; степени многочленов имею тип int (32 бита)
	; их необходимо расширить до 64 бит знаково
	cdqe								; знаковое расширение eax до rax
	movsxd r8, r8d						; пересылка младших 32 бит регистра r8 на себя с знаковым расширением
	; теперь все используемые регистры 64-битные
	; сделаем так, чтобы первый многочлен был не короче второго
	
	cmp r8, rax							; сравнение deg_a и deg_b
	; 2 последующих обмена будут производиться только при условии, что deg_a < deg_b
	; обмен степеней многочленов (rax, r8)
	cmovl r10, rax
	cmovl rax, r8
	cmovl r8, r10
	; обмен указателей на многочлены (rdx, r9)
	cmovl r10, rdx
	cmovl rdx, r9
	cmovl r9, r10

	; теперь первый многочлен не короче второго
	mov r10, r8							; инициализация первого индекса i
	mov r12, rax						; инициализация второго индекса j
	mov r13, r8							; инициализация индекса массива-результата k
	; далее следуют циклы
	cmp r12, 0							; сравнение j и 0
	jl m5								; if (j < 0) { переход к m5 }
	m1:
		mov r11, [rdx+8*r10]			; r11 = a[i]
		xor r11, [r9+8*r12]				; r11 += b[j]
		mov [rcx+8*r13], r11			; sum[k] = a[i] + b[j]
		dec r10							; i--
		dec r12							; j--
		dec r13							; k--
		cmp r12, 0						; сравнение r12 и 0
		jge m1							; если r12 < 0, переход к метке m2
	; далее дозапись "хвоста" первого массива
	m5:
	cmp r10, 0							; сравнение i и 0
	jl m4								; if (i < 0) { переход к метке m4 }
	m2:
		mov r11, [rdx+8*r10]			; r11 = a[i]
		mov [rcx+8*r13], r11			; sum[k] = a[i]
		dec r10							; i--
		dec r13							; k--
		cmp r10, 0
		jge m2
	m4:
	mov rax, r8							; возвращаемым значением является max(deg_a, deg_b)
	; восстановление значений регистров
	pop r13
	pop r12
	ret
PolySum ENDP

; Определяет поддержку процессором различных технологий
; Input:
;	rcx - 0 или 1, означает регистр, из которого будет извлекаться информация
;	0 соответствует регистру rcx, 1 соответствует регистру rdx
;	rdx - номер бита в данном регистре
; Output:
;	возвращет 1, если технология поддерживается
;	иначе 0
has_sse PROC							; rcx - 0 или 1: 0 - чтение из ecx, 1 - чтение из edx
										; rdx - номер бита
	mov rax, 01h						; параметр для cpuid для получения информации о процессоре
	mov r8, rdx							; сохранение rdx в r8
	mov r9, rcx							; сохранение rcx в r9
	cpuid
	cmp r9, 0							; сравнение r9 и 0
	cmovz rdx, rcx						; if (r9 == 0) { rdx = rcx; }
	xor rax, rax						; rax = 0
	bt rdx, r8							; копирование бита номер r8 из rdx в флаг CF
	mov r8, 1							; r8 = 1
	cmovc rax, r8						; if (cf == 1) { rax = r8; }
	ret
has_sse ENDP

END